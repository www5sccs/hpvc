// This file is part of the Peano project. For conditions of distribution and 
// use, please see the copyright notice at www.peano-framework.org
#ifndef _ROTATINGHEATSOURCE_EXPLICITEULER_STATE_H_ 
#define _ROTATINGHEATSOURCE_EXPLICITEULER_STATE_H_

#include "rotatingheatsource/expliciteuler/records/State.h"
#include "peano/grid/State.h"

#include "peano/grid/Checkpoint.h"

namespace rotatingheatsource { 
  namespace expliciteuler { 
      class State;
      /**
       * Forward declaration
       */
      class Vertex;
      /**
       * Forward declaration
       */
      class Cell;
      
      namespace repositories {
        /** 
         * Forward declaration
         */
        class RepositoryArrayStack;
        class RepositorySTDStack;
      }

      namespace mappings {
        class PerformExplicitEulerTimeStep;
      }
  }
}


/**
 * Blueprint for solver state.
 * 
 * This file has originally been created by the PDT and may be manually extended to 
 * the needs of your application. We do not recommend to remove anything!
 */
class rotatingheatsource::expliciteuler::State: public peano::grid::State< rotatingheatsource::expliciteuler::records::State > { 
  private: 
    friend class rotatingheatsource::expliciteuler::mappings::PerformExplicitEulerTimeStep;

    typedef class peano::grid::State< rotatingheatsource::expliciteuler::records::State >  Base;

    /**
     * Needed for checkpointing.
     */
    friend class rotatingheatsource::expliciteuler::repositories::RepositoryArrayStack;
    friend class rotatingheatsource::expliciteuler::repositories::RepositorySTDStack;
  
    void writeToCheckpoint( peano::grid::Checkpoint<Vertex,Cell>&  checkpoint ) const;    
    void readFromCheckpoint( const peano::grid::Checkpoint<Vertex,Cell>&  checkpoint );    
  
  public:
    /**
     * Default Constructor
     *
     * This constructor is required by the framework's data container. Do not 
     * remove it.
     */
    State();

    /**
     * Constructor
     *
     * This constructor is required by the framework's data container. Do not 
     * remove it. It is kind of a copy constructor that converts an object which 
     * comprises solely persistent attributes into a full attribute. This very 
     * functionality is implemented within the super type, i.e. this constructor 
     * has to invoke the correponsing super type's constructor and not the super 
     * type standard constructor.
     */
    State(const Base::PersistentState& argument);


    #ifdef Parallel
    /**
     * Merge two states
     *
     * This operation merges the PDE-specific data whenever something is
     * received from the worker. It is thus the counterpart of the
     * regulargrid's or spacetreegrid's mergeWithWorkerState(). Throughout
     * the merge, we need access to the aggregated data which is unfortunately
     * generated by DaStGen and only known in the subclasses. We thus use the
     * Bartonâ€“Nackman trick, and can write code that works for both the
     * regular and the spacetree grid.
     *
     * To make the implementation work, all subclasses have to make the
     * superclass their friend.
     */
    static void mergeApplicationSpecificDataWithWorkerState(State& masterState, const State& workerState);
    #endif

    void setTimeStepSize(double value);
    double getTimeStepSize() const;
    void setNextTime(double time);
    double getTime() const;
    int getTimeStep() const;
    double getUpdateInMaxNorm() const;
    double getUpdateInHNorm() const;
    double getNumberOfStencilUpdates() const;
    void clearMeasurements();
    std::string toString() const;
    double getUInHNorm() const;
    double getUInMaxNorm() const;

    void setUMeasurements( double uInMaxNorm, double updateInMaxNorm, double uInHNorm, double updateInHNorm );
    void incNumberOfStencilUpdates(double value);

    void setGlobalPlotCounter(int value);
    int getGlobalPlotCounter() const;
};

#endif
